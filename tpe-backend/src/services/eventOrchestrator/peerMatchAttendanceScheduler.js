// DATABASE-CHECKED: event_messages, contractors, event_attendees columns verified on 2025-10-18
/**
 * Peer Match Attendance Confirmation Scheduler
 *
 * Creates attendance confirmation messages after contractor responds YES to peer match
 * Confirms they actually met, then requests PCR if confirmed
 *
 * Flow:
 * 1. Contractor responds YES to peer match introduction
 * 2. peerMatchHandlers.js calls schedulePeerMatchAttendanceCheck()
 * 3. Creates attendance_check message scheduled for ~20 minutes after YES
 * 4. eventMessageWorker sends "Did you meet with {peer_name}?"
 * 5. attendanceHandlers.js processes YES/NO response
 * 6. If YES ‚Üí requests PCR for peer connection quality
 * 7. If NO ‚Üí acknowledges, no PCR needed
 */

const { query } = require('../../config/database');
const { safeJsonStringify } = require('../../utils/jsonHelpers');
const { scheduleEventMessage } = require('../../queues/eventMessageQueue');

/**
 * Schedule peer match attendance confirmation check
 * Called when contractor responds YES to peer match introduction
 *
 * @param {number} matchId - Peer match ID
 * @param {number} eventId - Event ID
 * @param {number} contractorId - Contractor ID
 * @param {Object} peerInfo - Peer contractor information
 * @param {number} delayMinutes - Minutes to wait before checking (default 20)
 * @returns {Object} - Scheduling result
 */
async function schedulePeerMatchAttendanceCheck(matchId, eventId, contractorId, peerInfo, delayMinutes = 20) {
  try {
    console.log(`[PeerMatchAttendanceScheduler] ü§ù Scheduling attendance check for match ${matchId}`);

    // Get contractor info
    const contractorResult = await query(`
      SELECT
        id,
        first_name,
        last_name,
        phone,
        email
      FROM contractors
      WHERE id = $1
    `, [contractorId]);

    if (contractorResult.rows.length === 0) {
      console.error(`[PeerMatchAttendanceScheduler] Contractor ${contractorId} not found`);
      return { success: false, error: 'Contractor not found' };
    }

    const contractor = contractorResult.rows[0];

    if (!contractor.phone) {
      console.error(`[PeerMatchAttendanceScheduler] Contractor ${contractorId} has no phone`);
      return { success: false, error: 'No phone number' };
    }

    // Calculate scheduled time: delayMinutes from now
    const scheduledTime = new Date(Date.now() + (delayMinutes * 60 * 1000));

    // Create attendance check message
    const message = await schedulePeerMatchAttendanceMessage(
      eventId,
      contractor,
      peerInfo,
      matchId,
      scheduledTime
    );

    console.log(`[PeerMatchAttendanceScheduler] ‚úÖ Attendance check ${message.message_id} scheduled for ${scheduledTime.toISOString()}`);

    return {
      success: true,
      message_id: message.message_id,
      match_id: matchId,
      contractor_id: contractorId,
      scheduled_time: scheduledTime,
      delay_minutes: delayMinutes
    };

  } catch (error) {
    console.error('[PeerMatchAttendanceScheduler] ‚ùå Error scheduling peer match attendance check:', error);
    throw error;
  }
}

/**
 * Schedule a single peer match attendance check message
 * Creates message in database and schedules via BullMQ
 *
 * @param {number} eventId - Event ID
 * @param {Object} contractor - Contractor receiving the check
 * @param {Object} peerInfo - Peer contractor information
 * @param {number} matchId - Peer match ID
 * @param {Date} scheduledTime - When to send the check
 * @returns {Object} - Scheduled message details
 */
async function schedulePeerMatchAttendanceMessage(eventId, contractor, peerInfo, matchId, scheduledTime) {
  try {
    // Prepare personalization data for attendance confirmation
    // attendanceHandlers.js expects: attendance_type, peer_name, match_id
    const personalizationData = {
      attendance_type: 'peer_match',
      peer_name: peerInfo.name || `${peerInfo.first_name} ${peerInfo.last_name}`,
      peer_company: peerInfo.company_name,
      match_id: matchId,
      peer_id: peerInfo.id
    };

    // Create message record in database
    const messageResult = await query(`
      INSERT INTO event_messages (
        event_id,
        contractor_id,
        message_type,
        message_category,
        scheduled_time,
        message_content,
        personalization_data,
        phone,
        status,
        direction,
        created_at,
        updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW())
      RETURNING id, scheduled_time
    `, [
      eventId,
      contractor.id,
      'attendance_check',
      'pcr_collection',
      scheduledTime,
      '', // Empty - will be generated by AI worker
      safeJsonStringify(personalizationData),
      contractor.phone,
      'scheduled',
      'outbound'
    ]);

    const message = messageResult.rows[0];

    // Schedule message in BullMQ
    await scheduleEventMessage({
      id: message.id,
      event_id: eventId,
      contractor_id: contractor.id,
      message_type: 'attendance_check',
      message_category: 'pcr_collection',
      scheduled_time: message.scheduled_time,
      message_content: '',
      personalization_data: personalizationData,
      phone: contractor.phone
    });

    console.log(`[PeerMatchAttendanceScheduler] Scheduled attendance check ${message.id} for contractor ${contractor.id}`);

    return {
      message_id: message.id,
      contractor_id: contractor.id,
      peer_name: personalizationData.peer_name,
      scheduled_time: message.scheduled_time
    };

  } catch (error) {
    console.error('[PeerMatchAttendanceScheduler] Error scheduling attendance check message:', error);
    throw error;
  }
}

module.exports = {
  schedulePeerMatchAttendanceCheck,
  schedulePeerMatchAttendanceMessage
};

name: Deploy to AWS Production

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
    types: [closed]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: tpe-app
  ECS_SERVICE: tpe-service
  ECS_CLUSTER: tpe-cluster
  STACK_NAME: TPE-Production

jobs:
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get CloudFormation Outputs
        id: cf-outputs
        run: |
          echo "Getting CloudFormation outputs..."
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
            --output text)
          DB_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseEndpoint`].OutputValue' \
            --output text)
          S3_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`DataLakeBucketName`].OutputValue' \
            --output text)
          
          echo "ALB_DNS=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_OUTPUT
          echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_OUTPUT

      # Backend Deployment
      - name: Setup Node.js for Backend
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Backend Dependencies
        working-directory: ./tpe-backend
        run: npm ci --production

      - name: Create Backend Environment File
        working-directory: ./tpe-backend
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          PORT=5000
          DATABASE_URL=postgresql://tpeadmin:${{ secrets.DB_PASSWORD }}@${{ steps.cf-outputs.outputs.DB_ENDPOINT }}:5432/tpe_production
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          FRONTEND_URL=http://${{ steps.cf-outputs.outputs.ALB_DNS }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          EOF

      - name: Run Database Migrations
        working-directory: ./tpe-backend
        run: |
          # Install PostgreSQL client
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          
          # Run migrations
          PGPASSWORD=${{ secrets.DB_PASSWORD }} psql \
            -h ${{ steps.cf-outputs.outputs.DB_ENDPOINT }} \
            -U tpeadmin \
            -d tpe_production \
            -f ../tpe-database/migrate-to-postgresql.sql || true
          
          # Load demo data for Destination Motivation
          PGPASSWORD=${{ secrets.DB_PASSWORD }} psql \
            -h ${{ steps.cf-outputs.outputs.DB_ENDPOINT }} \
            -U tpeadmin \
            -d tpe_production \
            -f ../tpe-database/destination-motivation-demo-data.sql || true

      # Frontend Deployment
      - name: Setup Node.js for Frontend
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Frontend Dependencies
        working-directory: ./tpe-front-end
        run: npm ci

      - name: Create Frontend Environment File
        working-directory: ./tpe-front-end
        run: |
          cat > .env.production << EOF
          NEXT_PUBLIC_API_URL=http://${{ steps.cf-outputs.outputs.ALB_DNS }}:5000
          NEXT_PUBLIC_ENVIRONMENT=production
          NEXT_PUBLIC_ALB_URL=http://${{ steps.cf-outputs.outputs.ALB_DNS }}
          EOF

      - name: Build Frontend
        working-directory: ./tpe-front-end
        run: npm run build

      # Deploy to S3 (for static assets)
      - name: Deploy Frontend to S3
        run: |
          # Use the existing S3 bucket from CloudFormation
          S3_BUCKET="${{ steps.cf-outputs.outputs.S3_BUCKET }}"
          
          if [ -z "$S3_BUCKET" ]; then
            echo "Warning: No S3 bucket found in CloudFormation outputs"
            echo "Skipping S3 deployment"
            exit 0
          fi
          
          echo "Deploying frontend assets to S3 bucket: $S3_BUCKET"
          
          # Upload frontend build to deployment folder
          cd tpe-front-end
          
          # Create deployment folder with timestamp
          DEPLOYMENT_FOLDER="deployments/frontend-$(date +%Y%m%d-%H%M%S)"
          
          # Upload static assets
          aws s3 sync .next/static s3://$S3_BUCKET/$DEPLOYMENT_FOLDER/_next/static --cache-control "public, max-age=31536000"
          aws s3 sync public s3://$S3_BUCKET/$DEPLOYMENT_FOLDER/public
          
          # Upload the entire build for reference
          aws s3 sync .next s3://$S3_BUCKET/$DEPLOYMENT_FOLDER/.next --exclude "cache/*"
          
          echo "Frontend deployed to: s3://$S3_BUCKET/$DEPLOYMENT_FOLDER"

      # Deploy to EC2 (Alternative - using Systems Manager)
      - name: Deploy Application to EC2
        run: |
          # Get EC2 Instance IDs from the stack (no ASG in current template)
          # For now, skip EC2 deployment since we don't have instances configured
          echo "Skipping EC2 deployment - no instances in current CloudFormation template"
          INSTANCE_IDS=""
          
          # Create deployment package
          tar -czf deploy-package.tar.gz \
            --exclude=node_modules \
            --exclude=.git \
            --exclude=.next/cache \
            tpe-backend tpe-front-end
          
          # Upload to S3
          aws s3 cp deploy-package.tar.gz s3://${{ steps.cf-outputs.outputs.S3_BUCKET }}/deployments/
          
          # Skip instance deployment if no instances
          if [ -z "$INSTANCE_IDS" ]; then
            echo "No EC2 instances to deploy to. Application available via S3."
          else
            for INSTANCE_ID in $INSTANCE_IDS; do
            aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters commands=["\
                cd /home/ec2-user && \
                aws s3 cp s3://${{ steps.cf-outputs.outputs.S3_BUCKET }}/deployments/deploy-package.tar.gz . && \
                tar -xzf deploy-package.tar.gz && \
                cd tpe-backend && npm install --production && \
                pm2 restart tpe-backend || pm2 start src/server.js --name tpe-backend && \
                cd ../tpe-front-end && npm install && npm run build && \
                pm2 restart tpe-frontend || pm2 start npm --name tpe-frontend -- start \
              "] \
              --output S3Bucket=${{ steps.cf-outputs.outputs.S3_BUCKET }} \
              --output S3KeyPrefix=logs/
            done
          fi

      - name: Output Deployment URLs
        run: |
          echo "ðŸš€ Deployment Complete!"
          echo "================================"
          echo "Application Load Balancer: http://${{ steps.cf-outputs.outputs.ALB_DNS }}"
          echo "Database Endpoint: ${{ steps.cf-outputs.outputs.DB_ENDPOINT }}"
          echo "S3 Data Lake: ${{ steps.cf-outputs.outputs.S3_BUCKET }}"
          echo "================================"
          echo "Frontend assets deployed to S3 bucket: ${{ steps.cf-outputs.outputs.S3_BUCKET }}/deployments/"
          echo "Database migrations applied successfully"
          echo "Demo data loaded for Destination Motivation"
          echo "================================"

      - name: Deploy to EC2 Server
        if: success()
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "ðŸš€ Deploying to EC2 server..."
          
          # Only proceed if EC2 credentials are configured
          if [ -n "$EC2_HOST" ] && [ -n "$EC2_KEY" ]; then
            # Setup SSH key
            echo "$EC2_KEY" > ec2_key
            chmod 600 ec2_key
            
            # Deploy to EC2
            ssh -o StrictHostKeyChecking=no -i ec2_key ${EC2_USER:-ubuntu}@${EC2_HOST} << 'ENDSSH'
              set -e
              cd /home/ubuntu/The-Power100-Experience
              
              echo "ðŸ”„ Pulling latest code from GitHub..."
              git pull origin main
              
              echo "ðŸ“¦ Installing any new dependencies..."
              npm install --legacy-peer-deps
              
              echo "ðŸ—ï¸ Building frontend..."
              cd tpe-front-end
              npm run build
              cd ..
              
              echo "â™»ï¸ Restarting PM2 services..."
              pm2 restart all
              pm2 save
              
              echo "âœ… EC2 deployment complete!"
              pm2 status
          ENDSSH
            
            rm -f ec2_key
            echo "âœ… Successfully deployed to EC2"
          else
            echo "âš ï¸ EC2 deployment skipped - no EC2 credentials configured"
            echo "To enable EC2 deployment, set the following secrets in GitHub:"
            echo "  - EC2_HOST (e.g., 3.95.250.211)"
            echo "  - EC2_SSH_KEY (private key content)"
            echo "  - EC2_USER (optional, defaults to 'ubuntu')"
          fi

      - name: Health Check
        run: |
          echo "Waiting for application to be ready..."
          sleep 30
          
          # Check if ALB is responding
          curl -f http://${{ steps.cf-outputs.outputs.ALB_DNS }} || echo "Frontend not yet responding"
          curl -f http://${{ steps.cf-outputs.outputs.ALB_DNS }}:5000/api/health || echo "Backend not yet responding"
          
          echo "Deployment verification complete!"